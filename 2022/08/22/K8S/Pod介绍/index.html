<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Chay">
    
    <title>
        
            Pod介绍 |
        
        Chay&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.png","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"君子藏器于身，待时而动。"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Chay&#39;s Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Pod介绍</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Chay</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2022-08-22 19:32:20
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/K8S/">K8S</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/K8S/">K8S</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>6.8k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>25 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="Kubernetes-Pod介绍"><a href="#Kubernetes-Pod介绍" class="headerlink" title="Kubernetes Pod介绍"></a>Kubernetes Pod介绍</h1><p>Pod直译是豆荚，可以把容器想像成豆荚里的豆子，把一个或多个关系紧密的豆子包在一起就是豆荚(一个Pod)。在k8s中我们不会直接操作容器，而是把容器包装成Pod再进行管理。</p>
<h2 id="Pod介绍与原理讲解"><a href="#Pod介绍与原理讲解" class="headerlink" title="Pod介绍与原理讲解"></a><a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/" >Pod介绍与原理讲解<i class="fas fa-external-link-alt"></i></a></h2><p>Pod是Kubernetes项目中最小的API对象。如果换一个更专业的说法，我们可以这样描述:<br><strong>Pod，是Kubernetes项目的原子调度单位。</strong></p>
<p>Pod是运行服务的基础，基础容器是<a class="link"   target="_blank" rel="noopener" href="https://www.ianlewis.org/en/almighty-pause-container" >pause<i class="fas fa-external-link-alt"></i></a>。每启动一个Pod都会附加启动这样一个容器，它的作用就只是简单的等待，回收僵尸进程。</p>
<p>一个 Pod 中的应用容器共享同一组资源:</p>
<ol>
<li>PID命名空间: Pod中的不同应用程序可以看见其他应用程序的进程ID</li>
<li>网络命名空间: Pod中的多个容器能访问同一个IP和端口范围</li>
<li>IPC命名空间: Pod中的多个容器能够使用SystemV IPC或POSIX消息队列进行通信</li>
<li>UTS命名空间: Pod中的多个容器共享一个主机名</li>
<li>Volumes(共享存储卷): Pod中的各个容器可以访问在Pod级别定义的Volumes</li>
</ol>
<p>每个 pod 中容器的镜像应该不同(不同的应用)，避免端口重复</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.staticaly.com/gh/dancing-monkey/image-hosting@master/image.4p1vnvavmuw0.webp"
                     
                ></p>
<p>Kubernetes 集群中的 Pod 主要有两种用法：</p>
<ul>
<li><strong>运行单个容器的 Pod</strong>。”每个 Pod 一个容器” 模型是最常见的 Kubernetes 用例； 在这种情况下，可以将 Pod 看作单个容器的包装器，并且 Kubernetes 直接管理 Pod，而不是容器。</li>
<li><strong>运行多个协同工作的容器的 Pod</strong>。 Pod 可能封装由多个紧密耦合且需要共享资源的共处容器组成的应用程序。 这些位于同一位置的容器可能形成单个内聚的服务单元 —— 一个容器将文件从共享卷提供给公众， 而另一个单独的 “边车”（sidecar）容器则刷新或更新这些文件。 Pod 将这些容器和存储资源打包为一个可管理的实体。</li>
</ul>
<blockquote>
<p>将多个并置、同管的容器组织到一个 Pod 中是一种相对高级的使用场景。 只有在一些场景中，容器之间紧密关联时才应该使用这种模式。</p>
</blockquote>
<p>每个 Pod 都旨在运行给定应用程序的单个实例。如果希望横向扩展应用程序 （例如，运行多个实例以提供更多的资源），则应该使用多个 Pod，每个实例使用一个 Pod。 在 Kubernetes 中，这通常被称为<strong>副本（Replication）</strong>。 通常使用一种工作负载资源及其<a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/" >控制器<i class="fas fa-external-link-alt"></i></a> 来创建和管理一组 Pod 副本。</p>
<h2 id="Pod创建"><a href="#Pod创建" class="headerlink" title="Pod创建"></a>Pod创建</h2><p>Pod 通常不是直接创建的，而是使用工作负载资源创建的。</p>
<h3 id="创建单个Pod"><a href="#创建单个Pod" class="headerlink" title="创建单个Pod"></a>创建单个Pod</h3><p>可以使用命令<code>kubectl run nginx --image=nginx:1.14.2 --port=80 --dry-run=client -o yaml&gt;nginx.yaml</code>来生成pod的yaml文件，这不会真正去创建pod。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">resources:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">status:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>kubectl apply -f nginx.yaml</code>命令来真正创建Pod。</p>
<h3 id="创建多容器Pod"><a href="#创建多容器Pod" class="headerlink" title="创建多容器Pod"></a>创建多容器Pod</h3><p>创建文件multi-container.yaml，并将以下信息复制到文件中。使用命令<code>kubectl apply -f multi-container.yaml</code>来创建Pod。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">multi-container</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">resources:</span> &#123;&#125;</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">tomcat</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">status:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用Pod"><a href="#使用Pod" class="headerlink" title="使用Pod"></a>使用Pod</h3><p>正常情况下很少在 Kubernetes 中直接创建一个个的 Pod，甚至是单实例（Singleton）的 Pod。 这是因为 Pod 被设计成了相对临时性的、用后即抛的一次性实体。 当 Pod 由你或者间接地由<a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/" >控制器<i class="fas fa-external-link-alt"></i></a> 创建时，它被调度在集群中的<a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/" >节点<i class="fas fa-external-link-alt"></i></a>上运行。 Pod 会保持在该节点上运行，直到 Pod 结束执行、Pod 对象被删除、Pod 因资源不足而被<strong>驱逐</strong>或者节点失效为止。</p>
<p>可以使用工作负载资源来创建和管理多个 Pod。 资源的控制器能够处理副本的管理、上线，并在 Pod 失效时提供自愈能力。 例如，如果一个节点失败，控制器注意到该节点上的 Pod 已经停止工作， 就可以创建替换性的 Pod。调度器会将替身 Pod 调度到一个健康的节点执行。</p>
<p>下面是一些管理一个或者多个 Pod 的工作负载资源的示例：</p>
<ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/" >Deployment<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/" >StatefulSet<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/" >DaemonSet<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="Pod生命周期"><a href="#Pod生命周期" class="headerlink" title="Pod生命周期"></a><a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/" >Pod生命周期<i class="fas fa-external-link-alt"></i></a></h2><p>Pod 的 <code>status</code> 字段是一个 <a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.25/#podstatus-v1-core" >PodStatus<i class="fas fa-external-link-alt"></i></a> 对象，其中包含一个 <code>phase</code> 字段。</p>
<p>Pod 的阶段（Phase）是 Pod 在其生命周期中所处位置的简单宏观概述。 该阶段并不是对容器或 Pod 状态的综合汇总，也不是为了成为完整的状态机。</p>
<p>Pod 阶段的数量和含义是严格定义的。 除了本文档中列举的内容外，不应该再假定 Pod 有其他的 <code>phase</code> 值。</p>
<p>下面是 <code>phase</code> 可能的值：</p>
<table>
<thead>
<tr>
<th align="left">取值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Pending</code>（悬决）</td>
<td align="left">Pod 已被 Kubernetes 系统接受，但有一个或者多个容器尚未创建亦未运行。此阶段包括等待 Pod 被调度的时间和通过网络下载镜像的时间。</td>
</tr>
<tr>
<td align="left"><code>Running</code>（运行中）</td>
<td align="left">Pod 已经绑定到了某个节点，Pod 中所有的容器都已被创建。至少有一个容器仍在运行，或者正处于启动或重启状态。</td>
</tr>
<tr>
<td align="left"><code>Succeeded</code>（成功）</td>
<td align="left">Pod 中的所有容器都已成功终止，并且不会再重启。</td>
</tr>
<tr>
<td align="left"><code>Failed</code>（失败）</td>
<td align="left">Pod 中的所有容器都已终止，并且至少有一个容器是因为失败终止。也就是说，容器以非 0 状态退出或者被系统终止。</td>
</tr>
<tr>
<td align="left"><code>Unknown</code>（未知）</td>
<td align="left">因为某些原因无法取得 Pod 的状态。这种情况通常是因为与 Pod 所在主机通信失败。</td>
</tr>
</tbody></table>
<p>如果某节点死掉或者与集群中其他节点失联，Kubernetes 会实施一种策略，将失去的节点上运行的所有 Pod 的 <code>phase</code> 设置为 <code>Failed</code>。</p>
<p>更进一步地，Pod 对象的 Status 字段，还可以再细分出一组 Conditions。这些细分状 态的值包括:PodScheduled、Ready、Initialized，以及 Unschedulable。它们主要用于描述 造成当前 Status 的具体原因是什么。</p>
<h2 id="Pod的资源和配额"><a href="#Pod的资源和配额" class="headerlink" title="Pod的资源和配额"></a><a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/configuration/manage-resources-containers/" >Pod的资源和配额<i class="fas fa-external-link-alt"></i></a></h2><p>以下 Pod 有两个容器。每个容器的请求为 0.25 CPU 和 64MiB（226 字节）内存， 每个容器的资源约束为 0.5 CPU 和 128MiB 内存。 你可以认为该 Pod 的资源请求为 0.5 CPU 和 128 MiB 内存，资源限制为 1 CPU 和 256MiB 内存。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">images.my-company.example/app:v4</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;64Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;250m&quot;</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">log-aggregator</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">images.my-company.example/log-aggregator:v6</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;64Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;250m&quot;</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="静态Pod"><a href="#静态Pod" class="headerlink" title="静态Pod"></a>静态Pod</h2><p><strong>静态 Pod（Static Pod）</strong>直接由特定节点上的 <code>kubelet</code> 守护进程管理， 不需要 <a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-apiserver" >API 服务器<i class="fas fa-external-link-alt"></i></a>看到它们。 尽管大多数 Pod 都是通过控制面（例如，<a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/" >Deployment<i class="fas fa-external-link-alt"></i></a>） 来管理的，对于静态 Pod 而言，<code>kubelet</code> 直接监控每个 Pod，并在其失效时重启之。</p>
<p>静态 Pod 通常绑定到某个节点上的 <a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubelet" >kubelet<i class="fas fa-external-link-alt"></i></a>。 其主要用途是运行自托管的控制面。 在自托管场景中，使用 <code>kubelet</code> 来管理各个独立的 <a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/overview/components/#control-plane-components" >控制面组件<i class="fas fa-external-link-alt"></i></a>。</p>
<p><code>kubelet</code> 自动尝试为每个静态 Pod 在 Kubernetes API 服务器上创建一个 <a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-mirror-pod" >镜像 Pod<i class="fas fa-external-link-alt"></i></a>。 这意味着在节点上运行的 Pod 在 API 服务器上是可见的，但不可以通过 API 服务器来控制。</p>
<h3 id="创建静态pod"><a href="#创建静态pod" class="headerlink" title="创建静态pod"></a><a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/static-pod/#behavior-of-static-pods" >创建静态pod<i class="fas fa-external-link-alt"></i></a></h3><p>以通过配置文件为例，来创建静态Pod。</p>
<p>在master节点的目录 /etc/kubernetes/manifests 写入 static.yaml 文件，内容:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">static-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">resources:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">status:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>等待一会儿后，会发现pod已经自动被创建了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifests]# kubectl get pod</span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">multi-container       2/2     Running   0          89m</span><br><span class="line">nginx                 1/1     Running   0          97m</span><br><span class="line">static-nginx-master   1/1     Running   0          5m57s</span><br></pre></td></tr></table></figure>

<p>由于静态 Pod 无法通过 API Server 直接管理，所以在 Master 节点尝试删除这个 Pod，将会 使其标为 Pending 状态，且不会被删除。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifests]# kubectl delete pod static-nginx-master</span><br><span class="line">pod &quot;static-nginx-master&quot; deleted</span><br><span class="line">[root@master manifests]# kubectl get pod</span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">multi-container       2/2     Running   0          94m</span><br><span class="line">nginx                 1/1     Running   0          102m</span><br><span class="line">static-nginx-master   0/1     Pending   0          4s</span><br></pre></td></tr></table></figure>

<p>删除该 Pod 的操作只能是到其所在 Node 上，将其自定义文件 static.yaml 从 /etc/kubernetes/manifests 目录下删除。<code>rm -f /etc/kubernetes/manifests/static.yaml</code></p>
<h2 id="初始化容器"><a href="#初始化容器" class="headerlink" title="初始化容器"></a><a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/init-containers/" >初始化容器<i class="fas fa-external-link-alt"></i></a></h2><p>初始化容器，顾名思义容器启动的时候，会先启动可一个或多个容器，如果有多个，那么这 几个 Init Container 按照定义的顺序依次执行，只有所有的 Init Container 执行完后，主容器 才会启动。由于一个 Pod 里的存储卷是共享的，所以 Init Container 里产生的数据可以被主 容器使用到。</p>
<p>Init Container 可以在多种 K8S 资源里被使用到如 Deployment、Daemon Set, Pet Set, Job 等， 但归根结底都是在 Pod 启动时，在主容器启动前执行，做初始化工作。<br>应用场景:</p>
<p>第一种场景:等待其它模块 Ready，比如我们有一个应用里面有两个容器化的服务，一个是 Web Server，另一个是数据库。其中 Web Server 需要访问数据库。但是当我们启动这个应 用的时候，并不能保证数据库服务先启动起来，所以可能出现在一段时间内 Web Server 有 数据库连接错误。为了解决这个问题，我们可以在运行 Web Server 服务的 Pod 里使用一个 InitContainer，去检查数据库是否准备好，直到数据库可以连接，Init Container 才结束退出， 然后 Web Server 容器被启动，发起正式的数据库连接请求。</p>
<p>第二种场景:初始化配置，比如集群里检测所有已经存在的成员节点，为主容器准备好集群 的配置信息，这样主容器起来后就能用这个配置信息加入集群。</p>
<p>其它使用场景:如将 pod 注册到一个中央数据库、下载应用依赖等。</p>
<h2 id="Pod的健康检查"><a href="#Pod的健康检查" class="headerlink" title="Pod的健康检查"></a><a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/" >Pod的健康检查<i class="fas fa-external-link-alt"></i></a></h2><p>探针是由 kubelet 对容器执行的定期诊断。要执行诊断，kubelet 调用由容器实现的 Handler。有三种类型的探针:</p>
<ul>
<li>Exec 探针:执行进程的地方，容器的状态由进程的退出状态代码确认。</li>
<li>Http get 探针:向容器发送 HTTP GET 请求，通过响应的 HTTP 状态代码判断容器是否准备 好;如果响应的状态码大于等于 200 且小于 400，则诊断被认为是成功的。</li>
<li>Tcp socket 探针:它打开一个 TCP 连接到容器的指定端口，如果连接己建立，则认为容器己 准备就绪。</li>
</ul>
<p>kubernetes 会周期性地调用探针，并根据就绪探针的结果采取行动。如果某个 pod 报告它 尚未准备就绪，则会从该服务中删除该 pod。如果 pod 再次准备就绪，则重新添加 pod; 每次探测都将获得以下三种结果之一:</p>
<ul>
<li>成功:容器通过了诊断。</li>
<li>失败:容器未通过诊断。</li>
<li>未知:诊断失败，因此不会采取任何行动 。</li>
</ul>
<p>livenessProbe(存活探针):指示容器是否正在运行。如果存活探测失败，则 kubelet 会杀死容器，并且 容器将受到其 重启策略 的影响。如果容器不提供存活探针，则默认状态为 Success 。</p>
<p>readinessProbe(就绪探针):指示容器是否准备好服务请求。如果就绪探测失败，端点控制器将从与 Pod 匹配的所有 Service 的端点中删除该 Pod 的 IP 地址。初始延迟之前的就绪状态默认为Failure。如果容器不提供就绪探针，则默认状态为 Success。</p>
<p>只要 pod 的标签和服务的 pod 选择器匹配，pod 就可以作为服务的后端，但是如果 pod 没有准备好，是不能处理请求的，这时候就需要就绪探针了，用来检查 pod 是否已经准备好 了，如果检查成功就可以作为服务的后端处理消息了。</p>
<h3 id="添加存活探针"><a href="#添加存活探针" class="headerlink" title="添加存活探针"></a>添加存活探针</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">test:</span> <span class="string">liveness</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">liveness-exec</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">k8s.gcr.io/busybox</span></span><br><span class="line">    <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">touch</span> <span class="string">/tmp/healthy;</span> <span class="string">sleep</span> <span class="number">30</span><span class="string">;</span> <span class="string">rm</span> <span class="string">-f</span> <span class="string">/tmp/healthy;</span> <span class="string">sleep</span> <span class="number">600</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>在这个配置文件中，可以看到 Pod 中只有一个 <code>Container</code>。 <code>periodSeconds</code> 字段指定了 kubelet 应该每 5 秒执行一次存活探测。 <code>initialDelaySeconds</code> 字段告诉 kubelet 在执行第一次探测前应该等待 5 秒。 kubelet 在容器内执行命令 <code>cat /tmp/healthy</code> 来进行探测。 如果命令执行成功并且返回值为 0，kubelet 就会认为这个容器是健康存活的。 如果这个命令返回非 0 值，kubelet 会杀死这个容器并重新启动它。</p>
<h3 id="添加就绪探针"><a href="#添加就绪探针" class="headerlink" title="添加就绪探针"></a>添加就绪探针</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">test:</span> <span class="string">liveness</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">liveness-exec</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">k8s.gcr.io/busybox</span></span><br><span class="line">    <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">touch</span> <span class="string">/tmp/healthy;</span> <span class="string">sleep</span> <span class="number">30</span><span class="string">;</span> <span class="string">rm</span> <span class="string">-f</span> <span class="string">/tmp/healthy;</span> <span class="string">sleep</span> <span class="number">600</span></span><br><span class="line">    <span class="attr">readinessProbe:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>



<h3 id="探针参数"><a href="#探针参数" class="headerlink" title="探针参数"></a>探针参数</h3><p><a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.25/#probe-v1-core" >Probe<i class="fas fa-external-link-alt"></i></a> 有很多配置字段，可以使用这些字段精确地控制活跃和就绪检测的行为：</p>
<ul>
<li><code>initialDelaySeconds</code>：容器启动后要等待多少秒后才启动存活和就绪探测器， 默认是 0 秒，最小值是 0。</li>
<li><code>periodSeconds</code>：执行探测的时间间隔（单位是秒）。默认是 10 秒。最小值是 1。</li>
<li><code>timeoutSeconds</code>：探测的超时后等待多少秒。默认值是 1 秒。最小值是 1。</li>
<li><code>successThreshold</code>：探测器在失败后，被视为成功的最小连续成功数。默认值是 1。 存活和启动探测的这个值必须是 1。最小值是 1。</li>
<li><code>failureThreshold</code>：当探测失败时，Kubernetes 的重试次数。 对存活探测而言，放弃就意味着重新启动容器。 对就绪探测而言，放弃意味着 Pod 会被打上未就绪的标签。默认值是 3。最小值是 1。</li>
</ul>
<h2 id="Pod调度"><a href="#Pod调度" class="headerlink" title="Pod调度"></a><a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/kube-scheduler/" >Pod调度<i class="fas fa-external-link-alt"></i></a></h2><p><strong>调度</strong> 是指将 <a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" >Pod<i class="fas fa-external-link-alt"></i></a> 放置到合适的<a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/" >节点<i class="fas fa-external-link-alt"></i></a>上，以便对应节点上的 <a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubelet" >Kubelet<i class="fas fa-external-link-alt"></i></a> 能够运行这些 Pod。</p>
<p>Pod的调度流程如下</p>
<ol>
<li><p>用户提交 pod，APIServer 记录到 etcd 中;</p>
</li>
<li><p>scheduler 周期性查询 APIServer，以获取未绑定的 pod，尝试为 pod 分配节点;</p>
</li>
<li><p>scheduler调度:首先过滤不符合pod资源要求的主机。然后考虑整体优化策略对主机打分，比如使用最低负载，使用分散主机等。最后选择最高分的主机存储绑定信息到 etcd 中;</p>
</li>
<li><p>kubelet 周期查询绑定对象，获取需要在本机启动的 pod 并通过 docker 启动。</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.staticaly.com/gh/dancing-monkey/image-hosting@master/image.28n13nfirb28.webp"
                     
                ></p>
<h3 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h3><p><a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-scheduler/" >kube-scheduler<i class="fas fa-external-link-alt"></i></a> 是 Kubernetes 集群的默认调度器，并且是集群 <a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane" >控制面<i class="fas fa-external-link-alt"></i></a> 的一部分。 如果你真得希望或者有这方面的需求，kube-scheduler 在设计上允许你自己编写一个调度组件并替换原有的 kube-scheduler。</p>
<p>对每一个新创建的 Pod 或者是未被调度的 Pod，kube-scheduler 会选择一个最优的节点去运行这个 Pod。 然而，Pod 内的每一个容器对资源都有不同的需求， 而且 Pod 本身也有不同的需求。因此，Pod 在被调度到节点上之前， 根据这些特定的调度需求，需要对集群中的节点进行一次过滤。</p>
<p>在一个集群中，满足一个 Pod 调度请求的所有节点称之为 <strong>可调度节点</strong>。 如果没有任何一个节点能满足 Pod 的资源请求， 那么这个 Pod 将一直停留在未调度状态直到调度器能够找到合适的 Node。</p>
<p>调度器先在集群中找到一个 Pod 的所有可调度节点，然后根据一系列函数对这些可调度节点打分， 选出其中得分最高的节点来运行 Pod。之后，调度器将这个调度决定通知给 kube-apiserver，这个过程叫做 <strong>绑定</strong>。</p>
<p>在做调度决定时需要考虑的因素包括：单独和整体的资源请求、硬件/软件/策略限制、 亲和以及反亲和要求、数据局部性、负载间的干扰等等。</p>
<h3 id="kube-scheduler-调度流程"><a href="#kube-scheduler-调度流程" class="headerlink" title="kube-scheduler 调度流程"></a>kube-scheduler 调度流程</h3><p>kube-scheduler 给一个 Pod 做调度选择时包含两个步骤：</p>
<ol>
<li>过滤</li>
<li>打分</li>
</ol>
<p>过滤阶段会将所有满足 Pod 调度需求的节点选出来。 例如，PodFitsResources 过滤函数会检查候选节点的可用资源能否满足 Pod 的资源请求。 在过滤之后，得出一个节点列表，里面包含了所有可调度节点；通常情况下， 这个节点列表包含不止一个节点。如果这个列表是空的，代表这个 Pod 不可调度。</p>
<p>在打分阶段，调度器会为 Pod 从所有可调度节点中选取一个最合适的节点。 根据当前启用的打分规则，调度器会给每一个可调度节点进行打分。</p>
<p>最后，kube-scheduler 会将 Pod 调度到得分最高的节点上。 如果存在多个得分最高的节点，kube-scheduler 会从中随机选取一个。</p>
<p>支持以下两种方式配置调度器的过滤和打分行为：</p>
<ol>
<li><a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/scheduling/policies" >调度策略<i class="fas fa-external-link-alt"></i></a> 允许你配置过滤所用的 <strong>断言（Predicates）</strong> 和打分所用的 <strong>优先级（Priorities）</strong>。</li>
<li><a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/scheduling/config/#profiles" >调度配置<i class="fas fa-external-link-alt"></i></a> 允许你配置实现不同调度阶段的插件， 包括：<code>QueueSort</code>、<code>Filter</code>、<code>Score</code>、<code>Bind</code>、<code>Reserve</code>、<code>Permit</code> 等等。 你也可以配置 kube-scheduler 运行不同的配置文件。</li>
</ol>
<h3 id="将pod调度到节点"><a href="#将pod调度到节点" class="headerlink" title="将pod调度到节点"></a><a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/assign-pods-nodes/" >将pod调度到节点<i class="fas fa-external-link-alt"></i></a></h3><h4 id="节点选择器"><a href="#节点选择器" class="headerlink" title="节点选择器"></a>节点选择器</h4><p>给某个node添加 <code>disktype=ssd</code> 标签：<code>kubectl label nodes &lt;your-node-name&gt; disktype=ssd</code></p>
<p>此 Pod 配置文件描述了一个拥有节点选择器 <code>disktype: ssd</code> 的 Pod。这表明该 Pod 将被调度到有 <code>disktype=ssd</code> 标签的节点。如果没有节点包含<code>disktype=ssd</code> 标签，Pod则处于Pending状态，直到找到包含<code>disktype=ssd</code> 标签的节点。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">env:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">disktype:</span> <span class="string">ssd</span></span><br></pre></td></tr></table></figure>

<h4 id="节点名称"><a href="#节点名称" class="headerlink" title="节点名称"></a>节点名称</h4><p>可以通过设置 <code>nodeName</code> 将某个 Pod 调度到特定的节点。如果节点名称不存在的话，Pod无法被调度，不会被创建。</p>
<p>使用 nodeName 来选择节点的一些限制:</p>
<ul>
<li>如果指定的节点不存在，则Pod调度失败。</li>
<li>如果指定的节点没有资源来容纳 Pod，Pod 将会调度失败并且其原因将显示 OutOfmemory 或 OutOfcpu。</li>
<li>云环境中的节点名称并非总是可预测或稳定的。</li>
</ul>
<p>如果 nodeName 在 PodSpec 中指定了，则它优先于节点选择方法。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">foo-node</span> <span class="comment"># 调度 Pod 到特定的节点</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br></pre></td></tr></table></figure>



<h3 id="亲和性与反亲和性"><a href="#亲和性与反亲和性" class="headerlink" title="亲和性与反亲和性"></a><a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity" >亲和性与反亲和性<i class="fas fa-external-link-alt"></i></a></h3><p><code>nodeSelector</code> 提供了一种最简单的方法来将 Pod 约束到具有特定标签的节点上。 亲和性和反亲和性扩展了你可以定义的约束类型。使用亲和性与反亲和性的一些好处有：</p>
<ul>
<li>亲和性、反亲和性语言的表达能力更强。<code>nodeSelector</code> 只能选择拥有所有指定标签的节点。 亲和性、反亲和性为你提供对选择逻辑的更强控制能力。</li>
<li>你可以标明某规则是“软需求”或者“偏好”，这样调度器在无法找到匹配节点时仍然调度该 Pod。</li>
<li>你可以使用节点上（或其他拓扑域中）运行的其他 Pod 的标签来实施调度约束， 而不是只能使用节点本身的标签。这个能力让你能够定义规则允许哪些 Pod 可以被放置在一起。</li>
</ul>
<p>亲和性功能由两种类型的亲和性组成：</p>
<ul>
<li><strong>节点亲和性</strong>功能类似于 <code>nodeSelector</code> 字段，但它的表达能力更强，并且允许你指定软规则。</li>
<li>Pod 间亲和性/反亲和性允许你根据其他 Pod 的标签来约束 Pod。</li>
</ul>
<h4 id="节点亲和性"><a href="#节点亲和性" class="headerlink" title="节点亲和性"></a><a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/assign-pods-nodes-using-node-affinity/" >节点亲和性<i class="fas fa-external-link-alt"></i></a></h4><p>节点亲和性概念上类似于 <code>nodeSelector</code>， 它使你可以根据节点上的标签来约束 Pod 可以调度到哪些节点上。 节点亲和性有两种：</p>
<ul>
<li><code>requiredDuringSchedulingIgnoredDuringExecution</code>： 调度器只有在规则被满足的时候才能执行调度。此功能类似于 <code>nodeSelector</code>， 但其语法表达能力更强。</li>
<li><code>preferredDuringSchedulingIgnoredDuringExecution</code>： 调度器会尝试寻找满足对应规则的节点。如果找不到匹配的节点，调度器仍然会调度该 Pod。</li>
</ul>
<blockquote>
<p>在上述类型中，<code>IgnoredDuringExecution</code> 意味着如果节点标签在 Kubernetes 调度 Pod 时发生了变更，Pod 仍将继续运行。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">with-node-affinity</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">topology.kubernetes.io/zone</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">antarctica-east1</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">antarctica-west1</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">preference:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">another-node-label-key</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">another-node-label-value</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">with-node-affinity</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">k8s.gcr.io/pause:2.0</span></span><br></pre></td></tr></table></figure>

<p>在这一示例中，所应用的规则如下：</p>
<ul>
<li>节点<strong>必须</strong>包含一个键名为 <code>topology.kubernetes.io/zone</code> 的标签， 并且该标签的取值<strong>必须</strong>为 <code>antarctica-east1</code> 或 <code>antarctica-west1</code>。</li>
<li>节点<strong>最好</strong>具有一个键名为 <code>another-node-label-key</code> 且取值为 <code>another-node-label-value</code> 的标签。</li>
</ul>
<p>你可以使用 <code>operator</code> 字段来为 Kubernetes 设置在解释规则时要使用的逻辑操作符。 你可以使用 <code>In</code>、<code>NotIn</code>、<code>Exists</code>、<code>DoesNotExist</code>、<code>Gt</code> 和 <code>Lt</code> 之一作为操作符。</p>
<p><code>NotIn</code> 和 <code>DoesNotExist</code> 可用来实现节点反亲和性行为。 你也可以使用<a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration/" >节点污点<i class="fas fa-external-link-alt"></i></a> 将 Pod 从特定节点上驱逐。</p>
<blockquote>
<p>如果同时指定了 <code>nodeSelector</code> 和 <code>nodeAffinity</code>，<strong>两者</strong> 必须都要满足， 才能将 Pod 调度到候选节点上。</p>
<p>如果指定了多个与 <code>nodeAffinity</code> 类型关联的 <code>nodeSelectorTerms</code>， 只要其中一个 <code>nodeSelectorTerms</code> 满足的话，Pod 就可以被调度到节点上。</p>
<p>如果指定了多个与同一 <code>nodeSelectorTerms</code> 关联的 <code>matchExpressions</code>， 则只有当所有 <code>matchExpressions</code> 都满足时 Pod 才可以被调度到节点上。</p>
</blockquote>
<h4 id="污点和容忍度"><a href="#污点和容忍度" class="headerlink" title="污点和容忍度"></a><a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration/" >污点和容忍度<i class="fas fa-external-link-alt"></i></a></h4><p><a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity" >节点亲和性<i class="fas fa-external-link-alt"></i></a> 是 <a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" >Pod<i class="fas fa-external-link-alt"></i></a> 的一种属性，它使 Pod 被吸引到一类特定的<a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/" >节点<i class="fas fa-external-link-alt"></i></a> （这可能出于一种偏好，也可能是硬性要求）。 <strong>污点（Taint）</strong> 则相反——它使节点能够排斥一类特定的 Pod。</p>
<p><strong>容忍度（Toleration）</strong> 是应用于 Pod 上的。容忍度允许调度器调度带有对应污点的 Pod。 容忍度允许调度但并不保证调度：作为其功能的一部分， 调度器也会<a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/pod-priority-preemption/" >评估其他参数<i class="fas fa-external-link-alt"></i></a>。</p>
<p>污点和容忍度（Toleration）相互配合，可以用来避免 Pod 被分配到不合适的节点上。 每个节点上都可以应用一个或多个污点，这表示对于那些不能容忍这些污点的 Pod， 是不会被该节点接受的。</p>
<p>给节点增加一个污点。比如，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes node1 key1=value1:NoSchedule</span><br></pre></td></tr></table></figure>

<p>给节点 <code>node1</code> 增加一个污点，它的键名是 <code>key1</code>，键值是 <code>value1</code>，效果是 <code>NoSchedule</code>。 这表示只有拥有和这个污点相匹配的容忍度的 Pod 才能够被分配到 <code>node1</code> 这个节点。</p>
<p>可以在 Pod 规约中为 Pod 设置容忍度。 下面的Pod配置的容忍度，则能够被调度到 <code>node1</code> ：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">env:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;key1&quot;</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">&quot;Equal&quot;</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line">    <span class="attr">effect:</span> <span class="string">&quot;NoSchedule&quot;</span></span><br></pre></td></tr></table></figure>

<p>给节点删除一个污点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes master node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure>



<h4 id="Pod间亲和性与反亲和性"><a href="#Pod间亲和性与反亲和性" class="headerlink" title="Pod间亲和性与反亲和性"></a>Pod间亲和性与反亲和性</h4><p>Pod 间亲和性与反亲和性使你可以基于已经在节点上运行的 <strong>Pod</strong> 的标签来约束 Pod 可以调度到的节点，而不是基于节点上的标签。</p>
<p>Pod 间亲和性与反亲和性的规则格式为“如果 X 上已经运行了一个或多个满足规则 Y 的 Pod， 则这个 Pod 应该（或者在反亲和性的情况下不应该）运行在 X 上”。 这里的 X 可以是节点、机架、云提供商可用区或地理区域或类似的拓扑域， Y 则是 Kubernetes 尝试满足的规则。</p>
<p>你通过<a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/#label-selectors" >标签选择算符<i class="fas fa-external-link-alt"></i></a> 的形式来表达规则（Y），并可根据需要指定选关联的名字空间列表。 Pod 在 Kubernetes 中是名字空间作用域的对象，因此 Pod 的标签也隐式地具有名字空间属性。 针对 Pod 标签的所有标签选择算符都要指定名字空间，Kubernetes 会在指定的名字空间内寻找标签。</p>
<p>你会通过 <code>topologyKey</code> 来表达拓扑域（X）的概念，其取值是系统用来标示域的节点标签键。 相关示例可参见<a class="link"   target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/labels-annotations-taints/" >常用标签、注解和污点<i class="fas fa-external-link-alt"></i></a>。</p>
<blockquote>
<p>Pod 反亲和性需要节点上存在一致性的标签。换言之， 集群中每个节点都必须拥有与 <code>topologyKey</code> 匹配的标签。 如果某些或者所有节点上不存在所指定的 <code>topologyKey</code> 标签，调度行为可能与预期的不同。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">with-pod-affinity</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">podAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">security</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">S1</span></span><br><span class="line">        <span class="attr">topologyKey:</span> <span class="string">topology.kubernetes.io/zone</span></span><br><span class="line">    <span class="attr">podAntiAffinity:</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">100</span></span><br><span class="line">        <span class="attr">podAffinityTerm:</span></span><br><span class="line">          <span class="attr">labelSelector:</span></span><br><span class="line">            <span class="attr">matchExpressions:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">security</span></span><br><span class="line">              <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">              <span class="attr">values:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">S2</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="string">topology.kubernetes.io/zone</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">with-pod-affinity</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">k8s.gcr.io/pause:2.0</span></span><br></pre></td></tr></table></figure>

<p>本示例定义了一条 Pod 亲和性规则和一条 Pod 反亲和性规则。Pod 亲和性规则配置为 <code>requiredDuringSchedulingIgnoredDuringExecution</code>，而 Pod 反亲和性配置为 <code>preferredDuringSchedulingIgnoredDuringExecution</code>。</p>
<p>亲和性规则表示，仅当节点和至少一个已运行且有 <code>security=S1</code> 的标签的 Pod 处于同一区域时，才可以将该 Pod 调度到节点上。 更确切的说，调度器必须将 Pod 调度到具有 <code>topology.kubernetes.io/zone=V</code> 标签的节点上，并且集群中至少有一个位于该可用区的节点上运行着带有 <code>security=S1</code> 标签的 Pod。</p>
<p>反亲和性规则表示，如果节点处于 Pod 所在的同一可用区且至少一个 Pod 具有 <code>security=S2</code> 标签，则该 Pod 不应被调度到该节点上。 更确切地说， 如果同一可用区中存在其他运行着带有 <code>security=S2</code> 标签的 Pod 节点， 并且节点具有标签 <code>topology.kubernetes.io/zone=R</code>，Pod 不能被调度到该节点上。</p>
<p>查阅<a class="link"   target="_blank" rel="noopener" href="https://git.k8s.io/design-proposals-archive/scheduling/podaffinity.md" >设计文档<i class="fas fa-external-link-alt"></i></a> 以进一步熟悉 Pod 亲和性与反亲和性的示例。</p>
<p>你可以针对 Pod 间亲和性与反亲和性为其 <code>operator</code> 字段使用 <code>In</code>、<code>NotIn</code>、<code>Exists</code>、 <code>DoesNotExist</code> 等值。</p>
<p>原则上，<code>topologyKey</code> 可以是任何合法的标签键。出于性能和安全原因，<code>topologyKey</code> 有一些限制：</p>
<ul>
<li>对于 Pod 亲和性而言，在 <code>requiredDuringSchedulingIgnoredDuringExecution</code> 和 <code>preferredDuringSchedulingIgnoredDuringExecution</code> 中，<code>topologyKey</code> 不允许为空。</li>
<li>对于 <code>requiredDuringSchedulingIgnoredDuringExecution</code> 要求的 Pod 反亲和性， 准入控制器 <code>LimitPodHardAntiAffinityTopology</code> 要求 <code>topologyKey</code> 只能是 <code>kubernetes.io/hostname</code>。如果你希望使用其他定制拓扑逻辑， 你可以更改准入控制器或者禁用之。</li>
</ul>
<p>除了 <code>labelSelector</code> 和 <code>topologyKey</code>，你也可以指定 <code>labelSelector</code> 要匹配的命名空间列表，方法是在 <code>labelSelector</code> 和 <code>topologyKey</code> 所在层同一层次上设置 <code>namespaces</code>。 如果 <code>namespaces</code> 被忽略或者为空，则默认为 Pod 亲和性/反亲和性的定义所在的命名空间。</p>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/09/01/K8S/%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">工作负载</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/06/13/K8S/Prometheus&amp;Grafana%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Prometheus&amp;Grafana安装及使用</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'A4KCp6T52xY83SQIkEScuKsd-gzGzoHsz',
                    appKey: 'RocCmgouj5izXvuXVbRcaTDd',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Chay';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2023&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Chay</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Kubernetes-Pod%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">Kubernetes Pod介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Pod%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3"><span class="nav-number">1.1.</span> <span class="nav-text">Pod介绍与原理讲解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pod%E5%88%9B%E5%BB%BA"><span class="nav-number">1.2.</span> <span class="nav-text">Pod创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%8D%95%E4%B8%AAPod"><span class="nav-number">1.2.1.</span> <span class="nav-text">创建单个Pod</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%AE%B9%E5%99%A8Pod"><span class="nav-number">1.2.2.</span> <span class="nav-text">创建多容器Pod</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Pod"><span class="nav-number">1.2.3.</span> <span class="nav-text">使用Pod</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pod%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.3.</span> <span class="nav-text">Pod生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pod%E7%9A%84%E8%B5%84%E6%BA%90%E5%92%8C%E9%85%8D%E9%A2%9D"><span class="nav-number">1.4.</span> <span class="nav-text">Pod的资源和配额</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81Pod"><span class="nav-number">1.5.</span> <span class="nav-text">静态Pod</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81pod"><span class="nav-number">1.5.1.</span> <span class="nav-text">创建静态pod</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E5%99%A8"><span class="nav-number">1.6.</span> <span class="nav-text">初始化容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pod%E7%9A%84%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5"><span class="nav-number">1.7.</span> <span class="nav-text">Pod的健康检查</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%AD%98%E6%B4%BB%E6%8E%A2%E9%92%88"><span class="nav-number">1.7.1.</span> <span class="nav-text">添加存活探针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%B0%B1%E7%BB%AA%E6%8E%A2%E9%92%88"><span class="nav-number">1.7.2.</span> <span class="nav-text">添加就绪探针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A2%E9%92%88%E5%8F%82%E6%95%B0"><span class="nav-number">1.7.3.</span> <span class="nav-text">探针参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pod%E8%B0%83%E5%BA%A6"><span class="nav-number">1.8.</span> <span class="nav-text">Pod调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#kube-scheduler"><span class="nav-number">1.8.1.</span> <span class="nav-text">kube-scheduler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kube-scheduler-%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B"><span class="nav-number">1.8.2.</span> <span class="nav-text">kube-scheduler 调度流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86pod%E8%B0%83%E5%BA%A6%E5%88%B0%E8%8A%82%E7%82%B9"><span class="nav-number">1.8.3.</span> <span class="nav-text">将pod调度到节点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9%E5%99%A8"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">节点选择器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E5%90%8D%E7%A7%B0"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">节点名称</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%B2%E5%92%8C%E6%80%A7%E4%B8%8E%E5%8F%8D%E4%BA%B2%E5%92%8C%E6%80%A7"><span class="nav-number">1.8.4.</span> <span class="nav-text">亲和性与反亲和性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E4%BA%B2%E5%92%8C%E6%80%A7"><span class="nav-number">1.8.4.1.</span> <span class="nav-text">节点亲和性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%A1%E7%82%B9%E5%92%8C%E5%AE%B9%E5%BF%8D%E5%BA%A6"><span class="nav-number">1.8.4.2.</span> <span class="nav-text">污点和容忍度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pod%E9%97%B4%E4%BA%B2%E5%92%8C%E6%80%A7%E4%B8%8E%E5%8F%8D%E4%BA%B2%E5%92%8C%E6%80%A7"><span class="nav-number">1.8.4.3.</span> <span class="nav-text">Pod间亲和性与反亲和性</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
