<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Chay">
    
    <title>
        
            Mysql索引优化二 |
        
        Chay&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.png","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"君子藏器于身，待时而动。"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Chay&#39;s Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Mysql索引优化二</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Chay</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-11-18 11:19:46
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Database/">Database</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Mysql/">Mysql</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>5k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>19 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="分页查询优化"><a href="#分页查询优化" class="headerlink" title="分页查询优化"></a>分页查询优化</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `employees` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">24</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">  `position` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;职位&#x27;</span>,</span><br><span class="line">  `hire_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;入职时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_name_age_position` (`name`,`age`,`position`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;员工记录表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>很多时候我们业务系统实现分页功能可能会用如下sql实现</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees limit <span class="number">10000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>表示从表 employees 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010 条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率是非常低的。</p>
<h2 id="根据自增且连续的主键排序的分页查询"><a href="#根据自增且连续的主键排序的分页查询" class="headerlink" title="根据自增且连续的主键排序的分页查询"></a><strong>根据自增且连续的主键排序的分页查询</strong></h2><p>首先来看一个根据自增且连续主键排序的分页查询的例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees limit <span class="number">90000</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/dancing-monkey/image-hosting@master/20211118/image.5yg6njm1bgw0.png"
                     
                ></p>
<p>该 SQL 表示查询从第 90001开始的五行数据，没添加单独 order by，表示通过<strong>主键排序</strong>。我们再看表 employees ，因为主键是自增并且连续的，所以可以改写成按照主键去查询从第 90001开始的五行数据，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">90000</span> limit <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/dancing-monkey/image-hosting@master/20211118/image.19l7pj1cne2o.png"
                     
                ></p>
<p>查询的结果是一致的。我们再对比一下执行计划：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees limit <span class="number">90000</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/dancing-monkey/image-hosting@master/20211118/image.5k25yr9je2s0.png"
                     
                ></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">90000</span> limit <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/dancing-monkey/image-hosting@master/20211118/image.44l9q0pb0ti0.png"
                     
                ></p>
<p>显然改写后的 SQL 走了索引，而且扫描的行数大大减少，执行效率更高。 </p>
<p>但是，这条改写的SQL 在很多场景并不实用，因为表中可能某些记录被删后，主键空缺，导致结果不一致。如果主键不连续，不能使用上面描述的优化方法。</p>
<p>另外如果原 SQL 是 order by 非主键的字段，按照上面说的方法改写会导致两条 SQL 的结果不一致。所以这种改写得满足以下两个条件：</p>
<ul>
<li>主键自增且连续</li>
<li>结果是按照主键排序的</li>
</ul>
<h2 id="根据非主键字段排序的分页查询"><a href="#根据非主键字段排序的分页查询" class="headerlink" title="根据非主键字段排序的分页查询"></a><strong>根据非主键字段排序的分页查询</strong></h2><p>再看一个根据非主键字段排序的分页查询，SQL 如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> name limit <span class="number">90000</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/dancing-monkey/image-hosting@master/20211118/image.5x6lgez4pc40.png"
                     
                ></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> name limit <span class="number">90000</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/dancing-monkey/image-hosting@master/20211118/image.rk8kb1enmls.png"
                     
                ></p>
<p>发现并没有使用 name 字段的索引（key 字段对应的值为 null），具体原因上节课讲过：<strong>扫描整个索引并查找到没索引的行(可能要遍历多个索引树)的成本比扫描全表的成本更高，所以优化器放弃使用索引</strong>。<br>知道不走索引的原因，那么怎么优化呢？<br>其实关键是<strong>让排序时返回的字段尽可能少</strong>，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录，SQL改写如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees e <span class="keyword">inner</span> <span class="keyword">join</span> (<span class="keyword">select</span> id <span class="keyword">from</span> employees <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">90000</span>,<span class="number">5</span>) ed <span class="keyword">on</span> e.id <span class="operator">=</span> ed.id;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/dancing-monkey/image-hosting@master/20211118/image.bme10nfp06g.png"
                     
                ></p>
<p>需要的结果与原 SQL 一致，执行时间减少了一半以上，我们再对比优化前后sql的执行计划：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/dancing-monkey/image-hosting@master/20211118/image.5yth6t1tqlc0.png"
                     
                ></p>
<p>原 SQL 使用的是 filesort 排序，而优化后的 SQL 使用的是索引排序。</p>
<h1 id="Join关联查询优化"><a href="#Join关联查询优化" class="headerlink" title="Join关联查询优化"></a><strong>Join关联查询优化</strong></h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 示例表：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_a` (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入一些示例数据</span></span><br><span class="line"><span class="comment">-- 往t1表插入1万行记录</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> insert_t1; </span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_t1()        </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;                    </span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;                          </span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">10000</span>)do                 </span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t1(a,b) <span class="keyword">values</span>(i,i);  </span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;                       </span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> insert_t1();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 往t2表插入100行记录</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> insert_t2; </span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_t2()        </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;                    </span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;                          </span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">100</span>)do                 </span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t2(a,b) <span class="keyword">values</span>(i,i);  </span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;                       </span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> insert_t2();</span><br></pre></td></tr></table></figure>

<p><strong>mysql的表关联常见有两种算法</strong></p>
<ul>
<li><p>Nested-Loop Join 算法</p>
</li>
<li><p>Block Nested-Loop Join 算法</p>
</li>
</ul>
<h2 id="嵌套循环连接-Nested-Loop-Join-NLJ-算法"><a href="#嵌套循环连接-Nested-Loop-Join-NLJ-算法" class="headerlink" title="嵌套循环连接 Nested-Loop Join(NLJ) 算法"></a>嵌套循环连接 Nested-Loop Join(NLJ) 算法</h2><p>一次一行循环地从第一张表（称为<strong>驱动表</strong>）中读取行，在这行数据中取到关联字段，根据关联字段在另一张表（<strong>被驱动表</strong>）里取出满足条件的行，然后取出两张表的结果合集。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> t2 <span class="keyword">on</span> t1.a<span class="operator">=</span> t2.a;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/dancing-monkey/image-hosting@master/20211118/image.a8yl4hkfyrs.png"
                     
                ></p>
<p>从执行计划中可以看到这些信息：</p>
<ul>
<li><p>驱动表是 t2，被驱动表是 t1。先执行的就是驱动表(执行计划结果的id如果一样则按从上到下顺序执行sql)；优化器一般会优先选择<strong>小表做驱动表，</strong>用where条件过滤完驱动表，然后再跟被驱动表做关联查询。<strong>所以使用 inner join 时，排在前面的表并不一定就是驱动表。</strong></p>
</li>
<li><p>当使用left join时，左表是驱动表，右表是被驱动表，当使用right join时，右表时驱动表，左表是被驱动表，当使用join时，mysql会选择数据量比较小的表作为驱动表，大表作为被驱动表。</p>
</li>
<li><p>使用了 NLJ算法。一般 join 语句中，如果执行计划 Extra 中未出现 <strong>Using join buffer</strong> 则表示使用的 join 算法是 NLJ。</p>
</li>
<li><p><strong>上面sql的大致流程如下：</strong></p>
<ol>
<li>从表 t2 中读取一行数据（如果t2表有查询过滤条件的，用先用条件过滤完，再从过滤结果里取出一行数据）；</li>
<li>从第 1 步的数据中，取出关联字段 a，到表 t1 中查找；</li>
<li>取出表 t1 中满足条件的行，跟 t2 中获取到的结果合并，作为结果返回给客户端；</li>
<li>重复上面 3 步。</li>
</ol>
<p>整个过程会读取 t2 表的所有数据(<strong>扫描100行</strong>)，然后遍历这每行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表中的对应行(<strong>扫描100次 t1 表的索引，1次扫描可以认为最终只扫描 t1 表一行完整数据，也就是总共 t1 表也扫描了100行</strong>)。因此整个过程扫描了 <strong>200 行</strong>。</p>
<p>如果被驱动表的关联字段没索引，**使用NLJ算法性能会比较低(下面有详细解释)**，mysql会选择Block Nested-Loop Join算法。</p>
<h2 id="基于块的嵌套循环连接-Block-Nested-Loop-Join-BNL-算法"><a href="#基于块的嵌套循环连接-Block-Nested-Loop-Join-BNL-算法" class="headerlink" title="基于块的嵌套循环连接 Block Nested-Loop Join(BNL)算法"></a>基于块的嵌套循环连接 Block Nested-Loop Join(BNL)算法</h2><p>把<strong>驱动表</strong>的数据读入到 join_buffer 中，然后扫描<strong>被驱动表</strong>，把<strong>被驱动表</strong>每一行取出来跟 join_buffer 中的数据做对比。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span>EXPLAIN <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> t2 <span class="keyword">on</span> t1.b<span class="operator">=</span> t2.b;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/dancing-monkey/image-hosting@master/20211118/image.6fjdyrd461o0.png"
                     
                ></p>
<p>Extra 中 的Using join buffer (Block Nested Loop)说明该关联查询使用的是 BNL 算法。</p>
<p><strong>上面sql的大致流程如下：</strong></p>
<ol>
<li>把 t2 的所有数据放入到 <strong>join_buffer</strong> 中</li>
<li>把表 t1 中每一行取出来，跟 join_buffer 中的数据做对比</li>
<li>返回满足 join 条件的数据</li>
</ol>
<p>整个过程对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) = <strong>10100</strong>。并且 join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是 100 * 10000= <strong>100 万次</strong>。</p>
<p>这个例子里表 t2 才 100 行，要是表 t2 是一个大表，join_buffer 放不下怎么办呢？·</p>
<p>join_buffer 的大小是由参数 join_buffer_size 设定的，默认值是 256k。如果放不下表 t2 的所有数据话，策略很简单，就是<strong>分段放</strong>。</p>
<p>比如 t2 表有1000行记录， join_buffer 一次只能放800行数据，那么执行过程就是先往 join_buffer 里放800行记录，然后从 t1 表里取数据跟 join_buffer 中数据对比得到部分结果，然后清空  join_buffer ，再放入 t2 表剩余200行记录，再次从 t1 表里取数据跟 join_buffer 中数据对比。所以就多扫了一次 t1 表。</p>
<p><strong>被驱动表的关联字段没索引为什么要选择使用 BNL 算法而不使用 Nested-Loop Join 呢？</strong></p>
<p>如果上面第二条sql使用 Nested-Loop Join，那么扫描行数为 100 * 10000 = 100万次，这个是<strong>磁盘扫描</strong>。<br>很显然，用BNL磁盘扫描次数少很多，相比于磁盘扫描，BNL的内存计算会快得多。<br>因此MySQL对于被驱动表的关联字段没索引的关联查询，一般都会使用 BNL 算法。如果有索引一般选择 NLJ 算法，有索引的情况下 NLJ 算法比 BNL算法性能更高</p>
</li>
</ul>
<h2 id="对于关联sql的优化"><a href="#对于关联sql的优化" class="headerlink" title="对于关联sql的优化"></a><strong>对于关联sql的优化</strong></h2><ul>
<li><strong>关联字段加索引</strong>：让mysql做join操作时尽量选择NLJ算法，驱动表因为需要全部查询出来，所以过滤的条件也尽量要走索引，避免全表扫描，总之，能走索引的过滤条件尽量都走索引</li>
<li><strong>小表驱动大表</strong>：写多表连接sql时如果<strong>明确知道</strong>哪张表是小表可以用straight_join写法固定连接驱动方式，省去mysql优化器自己判断的时间</li>
</ul>
<p><strong>straight_join解释：straight_join</strong>功能同join类似，但能让左边的表来驱动右边的表，能改表优化器对于联表查询的执行顺序。<br>比如：select * from t2 straight_join t1 on t2.a = t1.a; 代表指定mysql选着 t2 表作为驱动表。</p>
<ul>
<li><strong>straight_join</strong>只适用于inner join，并不适用于left join，right join。（因为left join，right join已经代表指定了表的执行顺序）</li>
<li>尽可能让优化器去判断，因为大部分情况下mysql优化器是比人要聪明的。使用<strong>straight_join</strong>一定要慎重，因为部分情况下人为指定的执行顺序并不一定会比优化引擎要靠谱</li>
</ul>
<blockquote>
<p><strong>对于小表定义的明确</strong>:在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，<strong>过滤完成之后</strong>，计算参与 join 的各个字段的总数据量，<strong>数据量小的那个表，就是“小表”</strong>，应该作为驱动表。</p>
</blockquote>
<h1 id="in和exsits优化"><a href="#in和exsits优化" class="headerlink" title="in和exsits优化"></a>in和exsits优化</h1><p>原则：<strong>小表驱动大表</strong>，即小的数据集驱动大的数据集</p>
<ul>
<li><p><strong>in</strong><br>当B表的数据集小于A表的数据集时，in优于exists </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> B)  </span><br><span class="line">#等价于：</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">select</span> id <span class="keyword">from</span> B)&#123;</span><br><span class="line">	<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> A.id <span class="operator">=</span> B.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>exists</strong><br>当A表的数据集小于B表的数据集时，exists优于in<br>将主查询A的数据，放到子查询B中做条件验证，根据验证结果（true或false）来决定主查询的数据是否保留</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B <span class="keyword">where</span> B.id <span class="operator">=</span> A.id)</span><br><span class="line">#等价于:</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A)&#123;</span><br><span class="line">	<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> B <span class="keyword">where</span> B.id <span class="operator">=</span> A.id</span><br><span class="line">&#125;   </span><br><span class="line">#A表与B表的ID字段应建立索引</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>EXISTS (subquery)只返回TRUE或FALSE,因此子查询中的SELECT * 也可以用SELECT 1替换,官方说法是实际执行时会忽略SELECT清单,因此没有区别</li>
<li>EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比</li>
<li>EXISTS子查询往往也可以用JOIN来代替，何种最优需要具体问题具体分析</li>
</ol>
<h1 id="count-查询优化"><a href="#count-查询优化" class="headerlink" title="count(*)查询优化"></a><strong>count(*)查询优化</strong></h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 临时关闭mysql查询缓存，为了查看sql多次执行的真实时间</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> query_cache_size<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> query_cache_type<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> employees;</span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">select</span> <span class="built_in">count</span>(id) <span class="keyword">from</span> employees;</span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">select</span> <span class="built_in">count</span>(name) <span class="keyword">from</span> employees;</span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> employees;</span><br></pre></td></tr></table></figure>

<p><strong>注意：以上4条sql只有根据某个字段count不会统计字段为null值的数据行</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/dancing-monkey/image-hosting@master/20211118/image.54yqqra3v240.png"
                     
                ></p>
<p><strong>四个sql的执行计划一样，说明这四个sql执行效率应该差不多</strong></p>
<ul>
<li><p><strong>字段有索引</strong><br>count(*)≈count(1)&gt;count(字段)&gt;count(主键 id)<br>字段有索引，count(字段)统计走二级索引，二级索引存储数据比主键索引少，所以count(字段)&gt;count(主键 id)</p>
</li>
<li><p><strong>字段无索引</strong><br>count(*)≈count(1)&gt;count(主键 id)&gt;count(字段)<br>字段没有索引count(字段)统计走不了索引，count(主键 id)还可以走主键索引，所以count(主键 id)&gt;count(字段)</p>
</li>
</ul>
<blockquote>
<p>count(1)跟count(字段)执行过程类似，不过count(1)不需要取出字段统计，就用常量1做统计，count(字段)还需要取出字段，所以理论上count(1)比count(字段)会快一点</p>
<p>count(<em>) 是例外，mysql并不会把全部字段取出来，而是专门做了优化，不取值，按行累加，效率很高，所以不需要用count(列名)或count(常量)来替代 count(</em>)</p>
<p>为什么对于count(id)，mysql最终选择辅助索引而不是主键聚集索引？因为二级索引相对主键索引存储数据更少，检索性能应该更高，mysql内部做了点优化(应该是在5.7版本才优化)</p>
</blockquote>
<h2 id="查询mysql自己维护的总行数"><a href="#查询mysql自己维护的总行数" class="headerlink" title="查询mysql自己维护的总行数"></a><strong>查询mysql自己维护的总行数</strong></h2><p>对于<strong>myisam存储引擎</strong>的表做不带where条件的count查询性能是很高的，因为myisam存储引擎的表的总行数会被mysql存储在磁盘上，查询不需要计算</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/dancing-monkey/image-hosting@master/20211118/image.1srjmoeij3z4.png"
                     
                ></p>
<p>对于<strong>innodb存储引擎</strong>的表mysql不会存储表的总记录行数(因为有MVCC机制，后面会讲)，查询count需要实时计算</p>
<h2 id="show-table-status"><a href="#show-table-status" class="headerlink" title="show table status"></a><strong>show table status</strong></h2><p>如果只需要知道表总行数的估计值可以用如下sql查询，性能很高</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/dancing-monkey/image-hosting@master/20211118/image.3vt04set9yw0.png"
                     
                ></p>
<h2 id="将总数维护到Redis里"><a href="#将总数维护到Redis里" class="headerlink" title="将总数维护到Redis里"></a><strong>将总数维护到Redis里</strong></h2><p>插入或删除表数据行的时候同时维护redis里的表总行数key的计数值(用incr或decr命令)，但是这种方式可能不准，很难保证表操作和redis操作的事务一致性</p>
<h2 id="增加数据库计数表"><a href="#增加数据库计数表" class="headerlink" title="增加数据库计数表"></a><strong>增加数据库计数表</strong></h2><p>插入或删除表数据行的时候同时维护计数表，让他们在同一个事务里操作</p>
<h1 id="MySQL数据类型选择"><a href="#MySQL数据类型选择" class="headerlink" title="MySQL数据类型选择"></a><strong>MySQL数据类型选择</strong></h1><p>在MySQL中，选择正确的数据类型，对于性能至关重要。一般应该遵循下面两步：</p>
<ol>
<li>确定合适的大类型：数字、字符串、时间、二进制</li>
<li>确定具体的类型：有无符号、取值范围、变长定长等</li>
</ol>
<p>在MySQL数据类型设置方面，尽量用更小的数据类型，因为它们通常有更好的性能，花费更少的硬件资源。并且，尽量把字段定义为NOT NULL，避免使用NULL</p>
<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>范围（有符号）</th>
<th>范围（无符号）</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>1 字节</td>
<td>(-128, 127)</td>
<td>(0, 255)</td>
<td>小整数值</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2 字节</td>
<td>(-32 768, 32 767)</td>
<td>(0, 65 535)</td>
<td>大整数值</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3 字节</td>
<td>(-8 388 608, 8 388 607)</td>
<td>(0, 16 777 215)</td>
<td>大整数值</td>
</tr>
<tr>
<td>INT或INTEGER</td>
<td>4 字节</td>
<td>(-2 147 483 648, 2 147 483 647)</td>
<td>(0, 4 294 967 295)</td>
<td>大整数值</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8 字节</td>
<td>(-9 233 372 036 854 775 808, 9 223 372 036 854 775 807)</td>
<td>(0, 18 446 744 073 709 551 615)</td>
<td>极大整数值</td>
</tr>
<tr>
<td>FLOAT</td>
<td>4 字节</td>
<td>(-3.402 823 466 E+38, 1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td>0, (1.175 494 351 E-38, 3.402 823 466 E+38)</td>
<td>单精度浮点数值</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8 字节</td>
<td>(1.797 693 134 862 315 7 E+308, 2.225 073 858 507 201 4 E-308), 0, (2.225 073 858 507 201 4 E-308, 1.797 693 134 862 315 7 E+308)</td>
<td>0, (2.225 073 858 507 201 4 E-308, 1.797 693 134 862 315 7 E+308)</td>
<td>双精度浮点数值</td>
</tr>
<tr>
<td>DECIMAL</td>
<td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td>依赖于M和D的值</td>
<td>依赖于M和D的值</td>
<td>小数值</td>
</tr>
</tbody></table>
<p>优化建议</p>
<ol>
<li>如果整形数据没有负数，如ID号，建议指定为UNSIGNED无符号类型，容量可以扩大一倍</li>
<li>建议使用TINYINT代替ENUM、BITENUM、SET</li>
<li>避免使用整数的显示宽度(参看文档最后)，也就是说，不要用INT(10)类似的方法指定字段显示宽度，直接用INT</li>
<li>DECIMAL最适合保存准确度要求高，而且用于计算的数据，比如价格。但是在使用DECIMAL类型的时候，注意长度设置</li>
<li>建议使用整形类型来运算和存储实数，方法是，实数乘以相应的倍数后再操作</li>
<li>整数通常是最佳的数据类型，因为它速度快，并且能使用AUTO_INCREMENT</li>
</ol>
<h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><table>
<thead>
<tr>
<th>类型</th>
<th>大小(字节)</th>
<th>范围</th>
<th>格式</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>DATE</td>
<td>3</td>
<td>1000-01-01 到 9999-12-31</td>
<td>YYYY-MM-DD</td>
<td>日期值</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
<td>‘-838:59:59’ 到 ‘838:59:59’</td>
<td>HH:MM:SS</td>
<td>时间值或持续时间</td>
</tr>
<tr>
<td>YEAR</td>
<td>1</td>
<td>1901 到 2155</td>
<td>YYYY</td>
<td>年份值</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8</td>
<td>1000-01-01 00:00:00 到 9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4</td>
<td>1970-01-01 00:00:00 到 2038-01-19 03:14:07</td>
<td>YYYYMMDDhhmmss</td>
<td>混合日期和时间值，时间戳</td>
</tr>
</tbody></table>
<p>优化建议</p>
<ol>
<li>MySQL能存储的最小时间粒度为秒</li>
<li>建议用DATE数据类型来保存日期。MySQL中默认的日期格式是yyyy-mm-dd</li>
<li>用MySQL的内建类型DATE、TIME、DATETIME来存储时间，而不是使用字符串</li>
<li>当数据格式为TIMESTAMP和DATETIME时，可以用CURRENT_TIMESTAMP作为默认（MySQL5.6以后），MySQL会自动返回记录插入的确切时间</li>
<li>TIMESTAMP是UTC时间戳，与时区相关</li>
<li>DATETIME的存储格式是一个YYYYMMDD HH:MM:SS的整数，与时区无关，你存了什么，读出来就是什么</li>
<li>除非有特殊需求，一般的公司建议使用TIMESTAMP，它比DATETIME更节约空间，但是像阿里这样的公司一般会用DATETIME，因为不用考虑TIMESTAMP将来的时间上限问题</li>
<li>有时人们把Unix的时间戳保存为整数值，但是这通常没有任何好处，这种格式处理起来不太方便，并不推荐它</li>
</ol>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR</td>
<td>0-255字节</td>
<td>定长字符串，char(n)当插入的字符数不足n时(n代表字符数)，插入空格进行补充保存。在进行检索时，尾部的空格会被去掉。</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>0-65535 字节</td>
<td>变长字符串，varchar(n)中的n代表最大字符数，插入的字符数不足n时不会补充空格</td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>0-255字节</td>
<td>不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>0-255字节</td>
<td>短文本字符串</td>
</tr>
<tr>
<td>BLOB</td>
<td>0-65 535字节</td>
<td>二进制形式的长文本数据</td>
</tr>
<tr>
<td>TEXT</td>
<td>0-65 535字节</td>
<td>长文本数据</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>0-16 777 215字节</td>
<td>二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>0-16 777 215字节</td>
<td>中等长度文本数据</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>0-4 294 967 295字节</td>
<td>二进制形式的极大文本数据</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>0-4 294 967 295字节</td>
<td>极大文本数据</td>
</tr>
<tr>
<td>优化建议</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>字符串的长度相差较大用VARCHAR；字符串短，且所有值都接近一个长度用CHAR</li>
<li>CHAR和VARCHAR适用于包括人名、邮政编码、电话号码和不超过255个字符长度的任意字母数字组合。那些要用来计算的数字不要用VARCHAR类型保存，因为可能会导致一些与计算相关的问题。换句话说，可能影响到计算的准确性和完整性</li>
<li>尽量少用BLOB和TEXT，如果实在要用可以考虑将BLOB和TEXT字段单独存一张表，用id关联</li>
<li>BLOB系列存储二进制字符串，与字符集无关。TEXT系列存储非二进制字符串，与字符集相关</li>
<li>BLOB和TEXT都不能有默认值</li>
</ol>
<h1 id="INT显示宽度"><a href="#INT显示宽度" class="headerlink" title="INT显示宽度"></a><strong>INT显示宽度</strong></h1><p>我们经常会使用命令来创建数据表，而且同时会指定一个长度，如下。但是，这里的长度并非是TINYINT类型存储的最大长度，而是显示的最大长度。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`(</span><br><span class="line">	`id` TINYINT(<span class="number">2</span>) UNSIGNED</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里表示user表的id字段的类型是TINYINT，可以存储的最大数值是255。所以，在存储数据时，如果存入值小于等于255，如200，虽然超过2位，但是没有超出TINYINT类型长度，所以可以正常保存；如果存入值大于255，如500，那么MySQL会自动保存为TINYINT类型的最大值255。</p>
<p>在查询数据时，不管查询结果为何值，都按实际输出。这里TINYINT(2)中2的作用就是，当需要在查询结果前填充0时，命令中加上ZEROFILL就可以实现。</p>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/11/18/Database/Mysql/Mysql%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Mysql锁与事务隔离级别</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/11/16/Database/Mysql/MySql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%80/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Mysql索引优化一</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'A4KCp6T52xY83SQIkEScuKsd-gzGzoHsz',
                    appKey: 'RocCmgouj5izXvuXVbRcaTDd',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Chay';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2023&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Chay</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">1.</span> <span class="nav-text">分页查询优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E8%87%AA%E5%A2%9E%E4%B8%94%E8%BF%9E%E7%BB%AD%E7%9A%84%E4%B8%BB%E9%94%AE%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.1.</span> <span class="nav-text">根据自增且连续的主键排序的分页查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E9%9D%9E%E4%B8%BB%E9%94%AE%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.2.</span> <span class="nav-text">根据非主键字段排序的分页查询</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Join%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">2.</span> <span class="nav-text">Join关联查询优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5-Nested-Loop-Join-NLJ-%E7%AE%97%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">嵌套循环连接 Nested-Loop Join(NLJ) 算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%9D%97%E7%9A%84%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5-Block-Nested-Loop-Join-BNL-%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">基于块的嵌套循环连接 Block Nested-Loop Join(BNL)算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E5%85%B3%E8%81%94sql%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">2.3.</span> <span class="nav-text">对于关联sql的优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#in%E5%92%8Cexsits%E4%BC%98%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">in和exsits优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#count-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">4.</span> <span class="nav-text">count(*)查询优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2mysql%E8%87%AA%E5%B7%B1%E7%BB%B4%E6%8A%A4%E7%9A%84%E6%80%BB%E8%A1%8C%E6%95%B0"><span class="nav-number">4.1.</span> <span class="nav-text">查询mysql自己维护的总行数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#show-table-status"><span class="nav-number">4.2.</span> <span class="nav-text">show table status</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E6%80%BB%E6%95%B0%E7%BB%B4%E6%8A%A4%E5%88%B0Redis%E9%87%8C"><span class="nav-number">4.3.</span> <span class="nav-text">将总数维护到Redis里</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%A1%E6%95%B0%E8%A1%A8"><span class="nav-number">4.4.</span> <span class="nav-text">增加数据库计数表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9"><span class="nav-number">5.</span> <span class="nav-text">MySQL数据类型选择</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.1.</span> <span class="nav-text">数值类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4"><span class="nav-number">5.2.</span> <span class="nav-text">日期和时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">5.3.</span> <span class="nav-text">字符串</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#INT%E6%98%BE%E7%A4%BA%E5%AE%BD%E5%BA%A6"><span class="nav-number">6.</span> <span class="nav-text">INT显示宽度</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
